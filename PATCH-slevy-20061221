diff -Nur RBUDP.orig/Makefile RBUDP/Makefile
--- RBUDP.orig/Makefile	2006-05-26 12:41:52.000000000 -0500
+++ RBUDP/Makefile	2006-09-02 06:44:21.000000000 -0500
@@ -1,6 +1,8 @@
 CXXFLAGS= -O3 
 
-all: sendfile recvfile usend urecv sendfilelist recvfilelist
+PROGRAMS = sendfile recvfile usend urecv sendfilelist recvfilelist sendstream recvstream
+
+all: ${PROGRAMS}
 
 
 sendfile: sendfile.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpSender_c.cxx
@@ -21,7 +23,13 @@
 urecv: urecv.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpReceiver_c.cxx
 	g++ ${CXXFLAGS} -o urecv urecv.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpReceiver_c.cxx
 
+sendstream: sendstream.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpSender_c.cxx
+	g++ ${CXXFLAGS} -o sendstream sendstream.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpSender_c.cxx
+
+recvstream: recvstream.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpReceiver_c.cxx
+	g++ ${CXXFLAGS} -o recvstream recvstream.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpReceiver_c.cxx
+
 clean:
-	rm -f *.o sendfile recvfile sendfilelist recvfilelist usend urecv 
+	rm -f *.o ${PROGRAMS}
 
 
diff -Nur RBUDP.orig/PATCH-slevy-20061221 RBUDP/PATCH-slevy-20061221
--- RBUDP.orig/PATCH-slevy-20061221	1969-12-31 18:00:00.000000000 -0600
+++ RBUDP/PATCH-slevy-20061221	2006-12-27 10:18:07.908092698 -0600
@@ -0,0 +1,28 @@
+diff -Nur RBUDP.orig/Makefile RBUDP/Makefile
+--- RBUDP.orig/Makefile	2006-05-26 12:41:52.000000000 -0500
++++ RBUDP/Makefile	2006-09-02 06:44:21.000000000 -0500
+@@ -1,6 +1,8 @@
+ CXXFLAGS= -O3 
+ 
+-all: sendfile recvfile usend urecv sendfilelist recvfilelist
++PROGRAMS = sendfile recvfile usend urecv sendfilelist recvfilelist sendstream recvstream
++
++all: ${PROGRAMS}
+ 
+ 
+ sendfile: sendfile.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpSender_c.cxx
+@@ -21,7 +23,13 @@
+ urecv: urecv.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpReceiver_c.cxx
+ 	g++ ${CXXFLAGS} -o urecv urecv.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpReceiver_c.cxx
+ 
++sendstream: sendstream.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpSender_c.cxx
++	g++ ${CXXFLAGS} -o sendstream sendstream.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpSender_c.cxx
++
++recvstream: recvstream.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpReceiver_c.cxx
++	g++ ${CXXFLAGS} -o recvstream recvstream.cxx QUANTAnet_rbudpBase_c.cxx QUANTAnet_rbudpReceiver_c.cxx
++
+ clean:
+-	rm -f *.o sendfile recvfile sendfilelist recvfilelist usend urecv 
++	rm -f *.o ${PROGRAMS}
+ 
+ 
diff -Nur RBUDP.orig/progress.log RBUDP/progress.log
--- RBUDP.orig/progress.log	2006-07-03 15:18:43.000000000 -0500
+++ RBUDP/progress.log	1969-12-31 18:00:00.000000000 -0600
@@ -1 +0,0 @@
-100
diff -Nur RBUDP.orig/QUANTAnet_rbudpBase_c.cxx RBUDP/QUANTAnet_rbudpBase_c.cxx
--- RBUDP.orig/QUANTAnet_rbudpBase_c.cxx	2005-09-27 01:39:13.000000000 -0500
+++ RBUDP/QUANTAnet_rbudpBase_c.cxx	2006-12-20 13:23:26.000000000 -0600
@@ -22,6 +22,38 @@
 
 #include "QUANTAnet_rbudpBase_c.hxx"
 
+// Instantiate these here.  Why we should ever need to instantiate constants
+// beats me, but some linkers (ia64?) call them undefined if we use them
+// in subclasses but not in this class, or something.
+const int QUANTAnet_rbudpBase_c::SIZEOFFILENAME;
+const int QUANTAnet_rbudpBase_c::UDPSOCKBUF;
+const int QUANTAnet_rbudpBase_c::SUCCESS;
+const int QUANTAnet_rbudpBase_c::FAILED;
+
+static void checkbuf( int udpSockfd, int sockbufsize, int verbose )
+{
+    int oldsend = -1, oldrecv = -1;
+    int newsend = -1, newrecv = -1;
+    socklen_t olen = sizeof(int);
+
+    if(getsockopt(udpSockfd,SOL_SOCKET,SO_SNDBUF,&oldsend,&olen) < 0)
+	perror("getsockopt: SO_SNDBUF");
+    if(getsockopt(udpSockfd,SOL_SOCKET,SO_RCVBUF,&oldrecv,&olen) < 0)
+	perror("getsockopt: SO_RCVBUF");
+    if(sockbufsize > 0) {
+	if(setsockopt(udpSockfd,SOL_SOCKET,SO_SNDBUF,&sockbufsize,sizeof(sockbufsize)) < 0)
+	    perror("setsockopt: SO_SNDBUF");
+	if(setsockopt(udpSockfd,SOL_SOCKET,SO_RCVBUF,&sockbufsize,sizeof(sockbufsize)) < 0)
+	    perror("setsockopt: SO_RCVBUF");
+	if(getsockopt(udpSockfd,SOL_SOCKET,SO_SNDBUF,&newsend,&olen) < 0)
+	    perror("getsockopt: SO_SNDBUF");
+	if(getsockopt(udpSockfd,SOL_SOCKET,SO_RCVBUF,&newrecv,&olen) < 0)
+	    perror("getsockopt: SO_RCVBUF");
+    }
+    if(verbose) fprintf(stderr, "UDP sockbufsize was %d/%d now %d/%d (send/recv)\n",
+	    oldsend, oldrecv, newsend, newrecv);
+}
+
 void QUANTAnet_rbudpBase_c::passiveUDP(char *host)
 {
 	struct sockaddr_in cliaddr;
@@ -61,6 +93,8 @@
                 perror("connect() error");
                 exit(1);
         }
+
+	checkbuf( udpSockfd, udpSockBufSize, verbose );
 }
 
 int QUANTAnet_rbudpBase_c::connectTCP(char * host)
@@ -139,6 +173,8 @@
        		perror("UDP client bind error");
         	exit(1);
 	}
+
+	checkbuf( udpSockfd, udpSockBufSize, verbose );
 }
 
 void QUANTAnet_rbudpBase_c::initTCPServer()
@@ -250,12 +286,55 @@
 	/* Preset those bits unused */
 	for (i=startOfLastByte;i<8;i++)
         	errorBitmap[sizeofErrorBitmap-1] |= bits[i];
+
+	/* Hack: we're not sure whether the peer is the same
+	 * endian-ness we are, and the RBUDP protocol doesn't specify.
+	 * Let's assume that it's like us, but keep a flag
+	 * to set if we see unreasonable-looking sequence numbers.
+	 */
+	peerswap = false;
+}
+
+int  QUANTAnet_rbudpBase_c::ptohseq( int origseq )
+{
+    int seq = origseq;
+
+    if(peerswap)
+	seq = swab32( origseq );
+
+    if(seq < 0 || (seq >> 3) >= sizeofErrorBitmap-1) {
+	if(!peerswap) {
+	    peerswap = true;
+	    if(verbose) fprintf(stderr, "peer has different endian-ness from ours\n");
+	    return ptohseq( seq );
+	} else {
+	    fprintf(stderr, "Unreasonable RBUDP sequence number %d = %x\n",
+		origseq, origseq);
+	    return 0;
+	}
+    }
+    return seq;
 }
+	    
 
 void QUANTAnet_rbudpBase_c::updateErrorBitmap(long long seq)
 {
 	long long index_in_list, offset_in_index;
 	char bits[8] = {0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080};
+	if(peerswap)
+	    seq = swab32(seq);
+	if(seq < 0 || (seq >> 3) >= sizeofErrorBitmap-1) {
+	    if(!peerswap) {
+		peerswap = true;
+		if(verbose) fprintf(stderr, "peer has opposite endian-ness to ours, swapping seqno bytes\n");
+	    }
+	    seq = swab32(seq);
+	}
+	if(seq < 0 || (seq >> 3) >= sizeofErrorBitmap-1) {
+	    fprintf(stderr, "sequence number 0x%llx out of range 0..%d\n",
+		seq, sizeofErrorBitmap*8-1);
+	    return;
+	}
 	// seq starts with 0
 	index_in_list = seq >> 3;
 	index_in_list ++;
@@ -289,4 +368,42 @@
 return count;
 }
 
+// Utility functions
+
+/* Unconditionally swap bytes in a 32-bit value */
+int QUANTAnet_rbudpBase_c::swab32( int val )
+{
+   return ( ((val>>24)&0xFF) | ((val>>8)&0xFF00)
+	   | ((val&0xFF00)<<8) | ((val&0xFF)<<24) );
+}
+
+long long QUANTAnet_rbudpBase_c::htonll( long long lll )
+{
+   long long nll = 0;
+   unsigned char *cp = (unsigned char *)&nll;
 
+   cp[0] = (lll >> 56) & 0xFF;
+   cp[1] = (lll >> 48) & 0xFF;
+   cp[2] = (lll >> 40) & 0xFF;
+   cp[3] = (lll >> 32) & 0xFF;
+   cp[4] = (lll >> 24) & 0xFF;
+   cp[5] = (lll >> 16) & 0xFF;
+   cp[6] = (lll >>  8) & 0xFF;
+   cp[7] = (lll >>  0) & 0xFF;
+
+   return nll;
+}
+
+long long QUANTAnet_rbudpBase_c::ntohll( long long nll )
+{
+   unsigned char *cp = (unsigned char *)&nll;
+
+   return ((long long)cp[0] << 56) |
+	  ((long long)cp[1] << 48) |
+	  ((long long)cp[2] << 40) |
+	  ((long long)cp[3] << 32) |
+	  ((long long)cp[4] << 24) |
+	  ((long long)cp[5] << 16) |
+	  ((long long)cp[6] <<  8) |
+	  ((long long)cp[7] <<  0);
+}
diff -Nur RBUDP.orig/QUANTAnet_rbudpBase_c.hxx RBUDP/QUANTAnet_rbudpBase_c.hxx
--- RBUDP.orig/QUANTAnet_rbudpBase_c.hxx	2005-11-09 23:55:35.000000000 -0600
+++ RBUDP/QUANTAnet_rbudpBase_c.hxx	2006-12-15 15:00:59.000000000 -0600
@@ -85,6 +85,8 @@
 	int receivedNumberOfPackets;
 	int lastPayloadSize;
 	int usecsPerPacket;
+	int udpSockBufSize;
+	int verbose;
 
 	// RBUDP will reuse the existing tcp socket if it is true.
 	int hasTcpSock;
@@ -107,13 +109,22 @@
 	// UDP remote port
 	int udpRemotePort;
   
+	// Hack: peer has opposite endian-ness to ours!
+	// We detect this if an exchanged sequence number is
+	// out of range.
+	bool peerswap;
+
   // Size of the file name the receiver wants to get from the sender
   static const int SIZEOFFILENAME = 256;
 
+  static const int UDPSOCKBUF = 8388608;
+
   static const int SUCCESS = 1;
 
   static const int FAILED = -1;
 
+
+
 	struct sockaddr_in udpServerAddr;
 	long long * hashTable;
 	char * errorBitmap;
@@ -124,6 +135,10 @@
 	struct _endOfUdp endOfUdp;
 
 	int reportTime(struct timeval & curTime);
+
+  static long long htonll( long long );	/* conditional byte-swapping of 8-byte quantities */
+  static long long ntohll( long long );
+  static int       swab32( int );	/* unconditional byte-swapping of 4-byte quantity */
 	
 protected:	
 	/// Connect to a remote UDP server with the default UDP port
@@ -144,10 +159,24 @@
 	void initErrorBitmap();
 	/// Update the bitmap. Should be called every time when a UDP packet is received
 	void updateErrorBitmap(long long seq);
-	/// Update the hash table of need-to-send UDP packets.  Should be called when a new bitmap is received.:w
+	/// Update the hash table of need-to-send UDP packets.  Should be called when a new bitmap is received.
 	int updateHashTable();
+	/// convert peer's sequence numbers to our internal form (maybe byteswapped)
+	int ptohseq( int seq );
+
+	QUANTAnet_rbudpBase_c() {
+	    udpSockBufSize = UDPSOCKBUF;
+	    verbose = 2;	// chatty by default
+	}
+
+public:
+	/// UDP buffer size (must set before connectUDP()/passiveUDP(); default is UDPSOCKBUF)
+	void setUDPBufSize( int nbytes ) {
+	    udpSockBufSize = nbytes>0 ? udpSockBufSize : UDPSOCKBUF;
+	}
+	void setverbose( int v ) {
+	    verbose = v;
+	}
 };
 
 #endif
-	
-	
diff -Nur RBUDP.orig/QUANTAnet_rbudpReceiver_c.cxx RBUDP/QUANTAnet_rbudpReceiver_c.cxx
--- RBUDP.orig/QUANTAnet_rbudpReceiver_c.cxx	2005-11-10 00:11:12.000000000 -0600
+++ RBUDP/QUANTAnet_rbudpReceiver_c.cxx	2006-12-20 16:22:14.000000000 -0600
@@ -53,9 +53,10 @@
 void QUANTAnet_rbudpReceiver_c::receive(void * buffer, int bufSize, int packetSize)
 {
 	int done = 0;
-	struct timeval curTime;
+	struct timeval curTime, startTime;
 	
 	gettimeofday(&curTime, NULL);
+	startTime = curTime;
 	initReceiveRudp(buffer, bufSize, packetSize);	
 	initErrorBitmap();
 	while (!done)
@@ -68,12 +69,22 @@
 		reportTime(curTime);
 
 		gettimeofday(&curTime, NULL);
-		TRACE_DEBUG("Current time: %d %ld", curTime.tv_sec, curTime.tv_usec);
+		if(verbose>1) TRACE_DEBUG("Current time: %d %ld", curTime.tv_sec, curTime.tv_usec);
 		
 		if (updateHashTable() == 0)
 			done = 1;
 		
-		TRACE_DEBUG("Error: %d, Loss rate: %f", updateHashTable(), (double)updateHashTable()/(double)totalNumberOfPackets);
+		if(verbose) {
+		    float dt = (curTime.tv_sec - startTime.tv_sec) +
+			     1e-6*(curTime.tv_usec - startTime.tv_usec);
+		    int nerrors = updateHashTable();
+		    int got = packetSize * (totalNumberOfPackets - nerrors);
+		    float mbps = 1e-6 * 8 * got / (dt==0 ? .01 : dt);
+		    TRACE_DEBUG("Error: %d, Loss rate: %.5f Got %d/%dK in %.2fs (%g Mbit/s)",
+			nerrors,
+			(double)nerrors/(double)totalNumberOfPackets,
+			(int)(got>>10), (int)(bufSize>>10), dt, mbps);
+		}
 		
 		// Send back Error bitmap
 		if (writen(tcpSockfd, errorBitmap, sizeofErrorBitmap) != sizeofErrorBitmap)
@@ -121,35 +132,36 @@
 				perror("recvmsg error\n");
 				exit(1);
 			}
-			
+
+			int rcvseq = ptohseq( recvHeader.seq );
 			// make sure it is the expected packet
-			if (recvHeader.seq == seqno)
+			if (rcvseq == seqno)
 			{
-				updateErrorBitmap(recvHeader.seq);
+				updateErrorBitmap(rcvseq);
 				// next expected packet
 				packetno ++;
 			}
 			// if some packets lost before this packet, move this packet backward
-			else if (recvHeader.seq > seqno)
+			else if (rcvseq > seqno)
 			{
-				bcopy(iovRecv[1].iov_base, (char *)mainBuffer+(recvHeader.seq*payloadSize) , iovRecv[1].iov_len);
-				updateErrorBitmap(recvHeader.seq);
+				bcopy(iovRecv[1].iov_base, (char *)mainBuffer+(rcvseq*payloadSize) , iovRecv[1].iov_len);
+				updateErrorBitmap(rcvseq);
 				// missed some packets, next expected packet
 				do packetno ++;
-				while((recvHeader.seq != hashTable[packetno]) || (packetno > remainNumberOfPackets));
+				while((rcvseq != hashTable[packetno]) && (packetno <= remainNumberOfPackets));
 				if (packetno > remainNumberOfPackets)
 				{	
-					printf("recv error\n");
+					fprintf(stderr,"recv error\n");
 				}
 				packetno ++;
 			}
-			//TRACE_DEBUG("received %d", recvHeader.seq);
+			//TRACE_DEBUG("received %d -> %d", recvHeader.seq, rcvseq);
 		}
 		//receive end of UDP signal
 		else if (FD_ISSET(tcpSockfd, &rset))
 		{
 			done = 1;
-			TRACE_DEBUG("received TCP signal");
+			if(verbose) TRACE_DEBUG("received TCP signal");
                 	readn(tcpSockfd, (char *)&endOfUdp, sizeof(struct _endOfUdp));
 		}
 		else // time out
@@ -190,7 +202,7 @@
 		{
 			int temp = recv(udpSockfd, msg, packetSize, 0);
 			bcopy(msg, &recvHeader, sizeof(struct _rbudpHeader));
-			seqno = recvHeader.seq;
+			seqno = ptohseq( recvHeader.seq );
 
 			// If the packet is the last one, 
 			if (seqno < totalNumberOfPackets - 1)
@@ -211,8 +223,10 @@
 			if ((int)prog > oldprog) {
 				oldprog = (int)prog;
 				if (oldprog > 100) oldprog = 100;
-				fseek(progress, 0, SEEK_SET);
-				fprintf(progress, "%d\n", oldprog);
+				if(progress != 0) {
+				    fseek(progress, 0, SEEK_SET);
+				    fprintf(progress, "%d\n", oldprog);
+				}
 			}
 
 		}
@@ -231,6 +245,60 @@
 
 }
 
+int QUANTAnet_rbudpReceiver_c::getstream( int tofd, int packetSize )
+{
+   // Let sender know we're ready.
+   if (writen(tcpSockfd, "\0", 1) != 1)
+   {
+	perror("tcp send");
+	exit(1);
+   }
+
+   long long curSize = -1;
+   char *buf = 0;
+   int ok = SUCCESS;
+
+   for(;;) {
+
+       long long nbufSize, bufSize;
+       int n = readn(tcpSockfd, (char *)&nbufSize, sizeof(nbufSize));
+       if (n < 0) {
+	 fprintf(stderr,"read error.\n");
+	 return(FAILED);
+       }
+
+       bufSize = ntohll( nbufSize );
+
+       if(bufSize <= 0)
+	 break;
+
+       if(verbose>1) fprintf(stderr, "accepting %lld byte chunk\n", bufSize);
+
+       if(buf == 0 && bufSize != curSize) {
+	 if(buf) free(buf);
+         buf = (char *)malloc( bufSize );
+         if(buf == 0) {
+	     fprintf(stderr, "QUANTAnet_rbudpReceiver_c::getstream: Couldn't malloc %lld bytes for buffer\n", bufSize);
+	     ok = FAILED;
+	     break;
+	 }
+	 curSize = bufSize;
+	}
+
+	receive( buf, bufSize, packetSize );
+
+	if(write( tofd, buf, bufSize ) < bufSize) {
+	    fprintf(stderr, "QUANTAnet_rbudpReceiver_c::getstream: couldn't write %lld bytes\n", bufSize);
+	    ok = FAILED;
+	    break;
+	}
+    }
+    if(buf != 0)
+	free(buf);
+    ::close(tofd);
+    return(ok);
+}
+
 int QUANTAnet_rbudpReceiver_c::getfile(char * origFName, char * destFName, int packetSize)
 {
   // Send getfile message.
@@ -243,12 +311,13 @@
    long long filesize;
    int n = readn(tcpSockfd, (char *)&filesize, sizeof(filesize));
    if (n < 0) {
-     printf("read error.\n");
+     fprintf(stderr,"read error.\n");
      return(FAILED);
    }
 
-   filesize = ntohl(filesize);
-   printf("The size of the file is %d.\n", filesize);
+   /* Can't use ntohl() on long longs! */
+   filesize = ntohll(filesize);
+   fprintf(stderr,"The size of the file is %lld.\n", filesize);
    
    int fd = open(destFName, O_RDWR|O_CREAT|O_TRUNC, 0666);
    ftruncate(fd, filesize);
@@ -256,7 +325,7 @@
    char *buf;
    buf = (char *)mmap(NULL, filesize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (buf == MAP_FAILED) {
-     printf("mmap failed.\n");
+     fprintf(stderr,"mmap failed.\n");
      return FAILED;
    }
 
@@ -272,7 +341,7 @@
 {
   FILE *fp = fopen(fileList, "r");
   if (fp == NULL) {
-	printf("Error open file!\n");
+	fprintf(stderr,"Error open file!\n");
         return -1;
   }
 
@@ -294,12 +363,12 @@
    long long filesize;
    int n = readn(tcpSockfd, (char *)&filesize, sizeof(filesize));
    if (n < 0) {
-     printf("read error.\n");
+     fprintf(stderr,"read error.\n");
      return(FAILED);
    }
 
-   filesize = ntohl(filesize);
-   printf("The size of the file is %d.\n", filesize);
+   filesize = ntohll(filesize);
+   fprintf(stderr,"The size of the file is %lld.\n", filesize);
 
    int fd = open(destFName, O_RDWR|O_CREAT|O_TRUNC, 0666);
    ftruncate(fd, filesize);
@@ -307,7 +376,7 @@
    char *buf;
    buf = (char *)mmap(NULL, filesize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (buf == MAP_FAILED) {
-     printf("mmap failed.\n");
+     fprintf(stderr,"mmap failed.\n");
      return FAILED;
    }
 
@@ -357,16 +426,16 @@
 	errorBitmap = (char *)malloc(sizeofErrorBitmap);
 	hashTable = (long long *)malloc(totalNumberOfPackets * sizeof(long long));
 	
-	TRACE_DEBUG("totalNumberOfPackets: %d", totalNumberOfPackets);
+	if(verbose>1) TRACE_DEBUG("totalNumberOfPackets: %d", totalNumberOfPackets);
 
 	if (errorBitmap == NULL)
 	{
-		printf("malloc errorBitmap failed\n");
+		fprintf(stderr,"malloc errorBitmap failed\n");
 		return (-1);
 	}
 	if (hashTable == NULL)
 	{
-		printf("malloc hashTable failed\n");
+		fprintf(stderr,"malloc hashTable failed\n");
 		return (-1);
 	}
 
@@ -386,20 +455,23 @@
 #ifdef DEBUG
 	log = fopen("rbudprecv.log","w");
 #endif
-	progress = fopen("progress.log", "w");	
+	if(verbose>2)
+	    progress = fopen("progress.log", "w");	
+	else
+	    progress = 0;
 
 	passiveUDP(remoteHost);
 
 	if (!hasTcpSock) 
 	{
-		TRACE_DEBUG("try to connect the sender via TCP ...");
+		if(verbose) TRACE_DEBUG("try to connect the sender via TCP ...");
 		n = connectTCP(remoteHost);
 		if (n < 0)
 		{
-			printf("connecting TCP failed, make sure the sender has been started\n");
+			fprintf(stderr,"connecting TCP failed, make sure the sender has been started\n");
 			exit(1);
 		}
-		TRACE_DEBUG("tcp connected.");
+		if(verbose) TRACE_DEBUG("tcp connected.");
 	}
        
 	msgRecv.msg_name = NULL;
@@ -420,6 +492,6 @@
 #ifdef DEBUG
 	fclose(log);
 #endif
-	fclose(progress);
+	if(progress != 0)
+	    fclose(progress);
 }
-
diff -Nur RBUDP.orig/QUANTAnet_rbudpReceiver_c.hxx RBUDP/QUANTAnet_rbudpReceiver_c.hxx
--- RBUDP.orig/QUANTAnet_rbudpReceiver_c.hxx	2005-11-09 23:31:37.000000000 -0600
+++ RBUDP/QUANTAnet_rbudpReceiver_c.hxx	2006-07-02 20:24:09.000000000 -0500
@@ -88,6 +88,13 @@
 	*/
         int getfilelist(char * fileList, int packetSize);
 
+	/** Receive a stream, write it to a UNIX file descriptor
+		@param tofd   file descriptor to write data to
+		@param packetSize  payload size of each UDP packet
+	    (buffer size is determined by sender)
+	 */
+	int getstream( int tofd, int packetSize );
+
 	/** Initialize a RBUDP session in the receiving side
 		@param remoteHost the name of the sending host.
 	*/
diff -Nur RBUDP.orig/QUANTAnet_rbudpSender_c.cxx RBUDP/QUANTAnet_rbudpSender_c.cxx
--- RBUDP.orig/QUANTAnet_rbudpSender_c.cxx	2006-05-26 13:41:44.000000000 -0500
+++ RBUDP/QUANTAnet_rbudpSender_c.cxx	2006-12-20 13:44:37.000000000 -0600
@@ -53,36 +53,36 @@
 void QUANTAnet_rbudpSender_c::send(void * buffer, int bufSize, int sendRate, int packetSize)
 {
 	int done = 0;
-	struct timeval curTime;
+	struct timeval curTime, startTime;
 	double srate;
 	gettimeofday(&curTime, NULL);
+	startTime = curTime;
 	initSendRudp(buffer, bufSize, sendRate, packetSize);	
 	while (!done)
 	{
 		// blast UDP packets
-		TRACE_DEBUG("sending UDP packets");
+		if(verbose>1) TRACE_DEBUG("sending UDP packets");
 		reportTime(curTime);
 		udpSend();
 
 		srate = (double) remainNumberOfPackets * payloadSize * 8 / (double) reportTime(curTime);	
-		TRACE_DEBUG("real sending rate in this send is %f", srate);
+		if(verbose>1) TRACE_DEBUG("real sending rate in this send is %f", srate);
 		
 		// send end of UDP signal
-		TRACE_DEBUG("send to socket %d an end signal.", tcpSockfd); 
-		printf("write %d bytes.\n", sizeof(endOfUdp));
+		if(verbose>1) TRACE_DEBUG("send to socket %d an end signal.", tcpSockfd); 
+		if(verbose>1) fprintf(stderr,"write %d bytes.\n", sizeof(endOfUdp));
 		writen(tcpSockfd, (char *)&endOfUdp, sizeof(endOfUdp));
 		endOfUdp.round ++;
 
 		reportTime(curTime);
 		gettimeofday(&curTime, NULL);
-		TRACE_DEBUG("Current time: %d %ld", curTime.tv_sec, curTime.tv_usec);
+		if(verbose>1) TRACE_DEBUG("Current time: %d %ld", curTime.tv_sec, curTime.tv_usec);
 
 		// receive error list
-		TRACE_DEBUG("waiting for error bitmap");
+		if(verbose>1) TRACE_DEBUG("waiting for error bitmap");
 		
 		int n = readn(tcpSockfd, errorBitmap, sizeofErrorBitmap);
-	  if (n<0)
-	        {
+		if (n<0) {
         	        perror("read");
                 	exit(1);
 	        }
@@ -91,7 +91,7 @@
                 {
 			done = 1;
                         remainNumberOfPackets = 0;
-			TRACE_DEBUG("done.");
+			if(verbose>1) TRACE_DEBUG("done.");
                 }
 		else
 		{
@@ -99,14 +99,20 @@
 		}
 		
   	if (isFirstBlast)
-    {
-      isFirstBlast = 0;
-      double lossRate = (double)remainNumberOfPackets / (double)totalNumberOfPackets;
-//                        if (remainNumberOfPackets > 0)
-//                                usecsPerPacket = (int) ((double)usecsPerPacket / (1.0 - lossRate - 0.05));
-			TRACE_DEBUG("loss rate: %f", lossRate);
-                        TRACE_DEBUG("usecsPerPacket updated to %d", usecsPerPacket);
-     }
+	    {
+	      isFirstBlast = 0;
+	      double lossRate = (double)remainNumberOfPackets / (double)totalNumberOfPackets;
+	//	if (remainNumberOfPackets > 0)
+	//	    usecsPerPacket = (int) ((double)usecsPerPacket / (1.0 - lossRate - 0.05));
+		if(verbose>0) {
+		    float dt = (curTime.tv_sec - startTime.tv_sec)
+				+ 1e-6*(curTime.tv_usec - startTime.tv_usec);
+		    float mbps = 1e-6 * 8*bufSize / (dt == 0 ? .01 : dt);
+		    TRACE_DEBUG("loss rate: %f  on %dK in %.3f seconds (%.2f Mbits/s)",
+			lossRate, (int)bufSize >> 10, dt, mbps);
+		    if(verbose>1) TRACE_DEBUG("usecsPerPacket updated to %d", usecsPerPacket);
+		}
+	     }
 	}
 	free(errorBitmap);
 	free(hashTable);
@@ -144,7 +150,7 @@
 			
 			iovSend[1].iov_base = (char*)mainBuffer+(sendHeader.seq*payloadSize);
 			iovSend[1].iov_len = actualPayloadSize;
-			printf("sent %d, %d %d\n", sendHeader.seq, now.tv_sec, now.tv_usec);
+			if(verbose>1) fprintf(stderr,"sent %d, %d %d\n", sendHeader.seq, now.tv_sec, now.tv_usec);
 			if (sendmsg(udpSockfd, &msgSend, 0) < 0)
       {
   	   	perror("sendmsg");
@@ -204,42 +210,80 @@
 	free (msg);
 }
 
+int QUANTAnet_rbudpSender_c::sendstream( int fromfd, int sendRate, int packetSize, int bufSize )
+{
+  // Receive startup message
+  char ack[1];
+  int n = readn(tcpSockfd, ack, 1);
+  if (n < 0) {
+    fprintf(stderr,"stream ack read error.\n");
+    return(FAILED);
+  }
+
+
+   // allocate buffer
+   char *buf = (char *)malloc( bufSize );
+   if(buf == 0) {
+    fprintf(stderr, "QUANTAnet_rbudpSender_c::sendstream: Couldn't malloc %d bytes for buffer\n", bufSize);
+    return(FAILED);
+   }
+
+   long long bytesread;
+   
+   while((bytesread = readn( fromfd, buf, bufSize )) > 0) {
+      long long nread = htonll( bytesread );
+      if (writen(tcpSockfd, (char *)&nread, sizeof(nread)) != sizeof(nread))
+        {
+	  {
+	   fprintf(stderr,"tcp send failed.\n");
+	   free(buf);
+	   return(FAILED);
+	  }			
+        }
+	if(verbose>1) fprintf(stderr, "sending %lld bytes\n", bytesread);
+	send(buf, bytesread, sendRate, packetSize);
+   }
+   ::close(fromfd);
+   free(buf);
+   return ((bytesread == 0) ? SUCCESS /*clean EOF*/ : FAILED /*error*/);
+}
+
 int QUANTAnet_rbudpSender_c::sendfile(int sendRate, int packetSize)
 {
   // Receive the getfile message
   char fname[SIZEOFFILENAME];
   int n = readn(tcpSockfd, fname, SIZEOFFILENAME);
   if (n < 0) {
-    printf("read error.\n");
+    fprintf(stderr,"read error.\n");
     return(FAILED);
   }
 
-  printf("Send file %s\n", fname);
+  fprintf(stderr,"Send file %s\n", fname);
 
   struct stat filestat;
   if (stat(fname, &filestat) < 0) {
-    printf("stat error.\n");
+    fprintf(stderr,"stat error.\n");
     return(FAILED);
   }
 
   long long filesize = filestat.st_size;
-  printf("The size of the file is %d\n", filesize);
+  fprintf(stderr,"The size of the file is %lld\n", filesize);
 
-  long long nfilesize = htonl(filesize);
-  printf("write %d bytess.\n", sizeof(nfilesize));
+  long long nfilesize = htonll(filesize);
+  fprintf(stderr,"write %d bytess.\n", sizeof(nfilesize));
 
   // Send the file size to the receiver.
    if (writen(tcpSockfd, (char *)&nfilesize, sizeof(nfilesize)) != sizeof(nfilesize))
    {
      {
-       printf("tcp send failed.\n");
+       fprintf(stderr,"tcp send failed.\n");
        return(FAILED);
      }			
    }
 
    int fd = open(fname, O_RDONLY);
    if (fd < 0) {
-     printf("open file failed.\n");
+     fprintf(stderr,"open file failed.\n");
      return(FAILED);
    }
    char *buf = (char *)mmap(NULL, filesize, PROT_READ, MAP_SHARED, fd, 0);
@@ -261,7 +305,7 @@
   while (!isFinished) {
   int n = readn(tcpSockfd, fname, SIZEOFFILENAME);
   if (n <= 0) {
-    printf("read error.\n");
+    fprintf(stderr,"read error.\n");
     return(FAILED);
   }
 
@@ -270,31 +314,31 @@
   bzero((void*)test, SIZEOFFILENAME);
   if (strcmp(test, fname) != 0) { 
 
-  printf("Send file %s\n", fname);
+  fprintf(stderr,"Send file %s\n", fname);
   
   struct stat filestat;
   if (stat(fname, &filestat) < 0) {
-    printf("stat error.\n");
+    fprintf(stderr,"stat error.\n");
     return(FAILED);
   }
 
   long long filesize = filestat.st_size;
-  printf("The size of the file is %d\n", filesize);
+  fprintf(stderr,"The size of the file is %d\n", filesize);
 
-  long long nfilesize = htonl(filesize);
+  long long nfilesize = htonll(filesize);
 
   // Send the file size to the receiver.
    if (writen(tcpSockfd, (char *)&nfilesize, sizeof(nfilesize)) != sizeof(nfilesize))
    {
      {
-       printf("tcp send failed.\n");
+       fprintf(stderr,"tcp send failed.\n");
        return(FAILED);
      }
    }
 
    int fd = open(fname, O_RDONLY);
    if (fd < 0) {
-     printf("open file failed.\n");
+     fprintf(stderr,"open file failed.\n");
      return(FAILED);
    }
    char *buf = (char *)mmap(NULL, filesize, PROT_READ, MAP_SHARED, fd, 0);
@@ -342,17 +386,17 @@
 	endOfUdp.round = 0;
 	strncpy(endOfUdp.end, "EEE", 3);
 	
-	TRACE_DEBUG("totalNumberOfPackets: %d", totalNumberOfPackets);
-	TRACE_DEBUG("usecsPerPacket: %d", usecsPerPacket);
+	if(verbose>1) TRACE_DEBUG("totalNumberOfPackets: %d", totalNumberOfPackets);
+	if(verbose>1) TRACE_DEBUG("usecsPerPacket: %d", usecsPerPacket);
 	
 	if (errorBitmap == NULL)
 	{
-		printf("malloc errorBitmap failed\n");
+		fprintf(stderr,"malloc errorBitmap failed\n");
 		return (-1);
 	}
 	if (hashTable == NULL)
 	{
-		printf("malloc hashTable failed\n");
+		fprintf(stderr,"malloc hashTable failed\n");
 		return (-1);
 	}
 
diff -Nur RBUDP.orig/QUANTAnet_rbudpSender_c.hxx RBUDP/QUANTAnet_rbudpSender_c.hxx
--- RBUDP.orig/QUANTAnet_rbudpSender_c.hxx	2005-11-09 23:32:16.000000000 -0600
+++ RBUDP/QUANTAnet_rbudpSender_c.hxx	2006-07-02 21:03:43.000000000 -0500
@@ -90,6 +90,15 @@
 	*/
         int sendfilelist(int sendRate, int packetSize);
 
+        /** Send a data stream from a UNIX file descriptor
+	    to the receiver using RBUDP protocol.
+		@param fromfd   the file descriptor to fetch data from
+	        @param sendRate the first-pass UDP blasting rate in Kbps.
+		@param packetSize payload size of each UDP packet.
+		@param bufSize  buffer size -- data is sent in this-size chunks
+	*/
+        int sendstream(int fromfd, int sendRate, int packetSize, int bufSize = 64*1024*1024);
+
 	/** Initialize a RBUDP session
 		@param remoteHost the name of the receiving host
 	*/
diff -Nur RBUDP.orig/README.streaming RBUDP/README.streaming
--- RBUDP.orig/README.streaming	1969-12-31 18:00:00.000000000 -0600
+++ RBUDP/README.streaming	2006-12-20 17:01:53.000000000 -0600
@@ -0,0 +1,58 @@
+Changes contributed by slevy@ncsa.uiuc.edu
+
+   The file(list) apps were exchanging long long file-size values,
+   but using htonl()/ntohl() to convert them.  I think this doesn't work,
+   so added htonll()/ntohll() functions.
+
+   Also checked sanity of packet-sequence values in each data packet.
+   If they're out of range, but byte-swapping makes them reasonable,
+   then do so for that and all following packets.  This autodetects
+   having two ends with different byte order.  But we shouldn't have
+   to do it this way; better to have an explicit negotiation,
+   or a network-byte-order convention or something.
+
+   The file/filelist apps are still awkward though -- they map
+   in the entire file at once, so they fail on files too large
+   to fit in virtual memory.  Shipping large numbers of small files
+   works, but very inefficiently, since we pay the transfer-startup
+   cost on every single one.
+
+   So added new methods sendstream() and getstream(),
+   which support new apps "sendstream" and "recvstream",
+   intended for shipping arbitrary-length byte streams.
+   Typical use (see their Usage messages) might be:
+
+     tar cf - somedir | sendstream <receiverhost> 600m 1460
+
+     recvstream <senderhost> 1460 | tar xvpf -
+
+   Changed a bunch of library printf's to fprintf(stderr)'s
+   to avoid cluttering stdout so recvstream could work. 
+
+   Instantiated each of the "static const int"s in
+   the QUANTAnet_rbudpBase_c.cxx file; otherwise *some* linkers
+   (Altix ia64 at least) call them undefined at link time.
+   (How can a compile-time constant be undefined at link time??)
+
+   Set the socket-buffer size to 8MB by default, change-able by
+   calling QUANTAnet_rbudpBase_c::setUDPBufSize() before starting
+   to send/receive.
+
+   Adjustable verbose-ness from 0 (quiet, only serious errors shown),
+   1 (packet-loss stats), to 2 (as verbose as ever).
+   New setverbose() method call sets it, and -q/-v options in
+   usend/urecv/sendstream/recvstream apps use it.
+   The apps' default (neither -q nor -v) is 1.
+
+   Disabled writing "progress.log" file unless verboseness is 2.
+
+   Add block-size (default -b 64M) and port-number (default -p 38000)
+   options to send/recvstream.
+
+   Rearranged the parameter order on usend/urecv to make a little more sense.
+
+   Made helpful Usage messages on sendstream/recvstream and usend/urecv.
+
+   Packet-loss stats messages include transfer size and performance estimates.
+
+     - Stuart Levy, slevy@ncsa.uiuc.edu, July - Dec 2006
Files RBUDP.orig/recvfile and RBUDP/recvfile differ
Files RBUDP.orig/recvfilelist and RBUDP/recvfilelist differ
diff -Nur RBUDP.orig/recvstream.cxx RBUDP/recvstream.cxx
--- RBUDP.orig/recvstream.cxx	1969-12-31 18:00:00.000000000 -0600
+++ RBUDP/recvstream.cxx	2006-12-20 13:32:32.000000000 -0600
@@ -0,0 +1,117 @@
+/******************************************************************************
+ * QUANTA - A toolkit for High Performance Data Sharing
+ * Copyright (C) 2003 Electronic Visualization Laboratory,  
+ * University of Illinois at Chicago
+ *
+ * This library is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either Version 2.1 of the License, or 
+ * (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser Public License along
+ * with this library; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Direct questions, comments etc about Quanta to cavern@evl.uic.edu
+ *****************************************************************************/
+
+#include <getopt.h>
+#include "QUANTAnet_rbudpReceiver_c.hxx"
+
+char *prog;
+
+int getnumber( char *str, char *why, int vmin, int vmax, int dscale = 1 )
+{
+    int iv;
+    float v;
+    int ok = 1;
+    int c = '\0';
+    if( sscanf(str, "%f%c", &v, &c) > 0 ) {
+	switch(c) {
+	case 'k': case 'K': iv = (int)(v * (1<<10)); break;
+	case 'm': case 'M': iv = (int)(v * (1<<20)); break;
+	case 'g': case 'G': iv = (int)(v * (1<<30)); break;
+	case '\0': iv = (int)(v * dscale); break;
+	default:
+	    ok = 0;
+	    break;
+	}
+    } else {
+	ok = 0;
+    }
+    if(ok) {
+	if(vmin < vmax && !(vmin <= iv && iv <= vmax)) {
+	    fprintf(stderr, "%s: %s: value '%s' = %d out of range %d..%d\n",
+		prog, why, str, iv, vmin, vmax);
+	    exit(1);
+	} else {
+	    return iv;
+	}
+    }
+    fprintf(stderr, "%s: %s: expected number (possibly with k/m/g suffix), not '%s'\n",
+	prog, why, str);
+    exit(1);
+}
+
+int
+main (int argc, char **argv)
+{
+  struct timeval start, end;
+  double throughput;
+  int port = -1;
+  int verbose = 1;
+  int mtu;
+  char c;
+
+  prog = argv[0];
+
+  while((c = getopt(argc, argv, "qvp:b:")) != EOF) {
+    switch(c) {
+    case 'v': verbose++; break;
+    case 'q': verbose = 0; break;
+    case 'p': port = getnumber( optarg, "UDP/TCP port number (default 38000)", 1, 65535 ); break;
+    default:
+	argc = 0;
+	break;
+    }
+  }
+
+  if (argc < optind+2) {
+      fprintf(stderr, "Usage: recvstream [-v] [-q] [-p <port>] <receiver> <packetsize>\n\
+Receive a stream of RBUDP data sent by \"sendstream\", write it to standard output.\n\
+The <packetsize> (UDP payload data size) must be same as given to sendstream.\n\
+Use \"-v\" for verbose messaging, \"-q\" for quiet (errors-only),\n\
+  \"-p <port>\" to set port number (default 38000).\n\
+Firewalling: sendstream listens on both UDP and TCP port 38000 (or <port>);\n\
+	recvstream listens on UDP port 38001 (or <port>+1)\n\n\
+Start \"sendstream\" first, then \"recvstream\".  Example, sending at 250 Mbit/s:\n\
+   on sourcehost:   tar cf - ... | sendstream destIPaddr 250m 1460\n\
+then on desthost:   recvstream sourceIPaddr 1460 | tar xf -\n");
+      exit(1);
+  }
+
+  mtu = getnumber( argv[optind+1], "UDP data payload size (bytes, e.g. 1460 or 8800)", 8, 100000 );
+  if(port <= 0)
+    port = 38000;
+
+  QUANTAnet_rbudpReceiver_c *myreceiver = new QUANTAnet_rbudpReceiver_c (port);
+    
+  myreceiver->init (argv[optind]);
+  myreceiver->setverbose(verbose);
+
+  if(verbose > 0)
+    fprintf (stderr, "init finishes\n");
+  gettimeofday (&start, NULL);
+  myreceiver->getstream (1, mtu);
+  gettimeofday (&end, NULL);
+  myreceiver->close ();
+
+  if(verbose > 0)
+    fprintf (stderr, "time consumed: %d microseconds\n", USEC (&start, &end));
+  return 0;
+}
Files RBUDP.orig/sendfile and RBUDP/sendfile differ
Files RBUDP.orig/sendfilelist and RBUDP/sendfilelist differ
diff -Nur RBUDP.orig/sendstream.cxx RBUDP/sendstream.cxx
--- RBUDP.orig/sendstream.cxx	1969-12-31 18:00:00.000000000 -0600
+++ RBUDP/sendstream.cxx	2006-12-21 15:55:31.000000000 -0600
@@ -0,0 +1,125 @@
+/******************************************************************************
+ * QUANTA - A toolkit for High Performance Data Sharing
+ * Copyright (C) 2003 Electronic Visualization Laboratory,  
+ * University of Illinois at Chicago
+ *
+ * This library is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either Version 2.1 of the License, or 
+ * (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser Public License along
+ * with this library; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Direct questions, comments etc about Quanta to cavern@evl.uic.edu
+ *****************************************************************************/
+
+#include <getopt.h>
+#include "QUANTAnet_rbudpSender_c.hxx"
+
+char *prog;
+
+int getnumber( char *str, char *why, int vmin, int vmax, float dscale = 1, float vscale = 1.0f )
+{
+    int iv;
+    float v;
+    int ok = 1;
+    int c = '\0';
+    if( sscanf(str, "%f%c", &v, &c) > 0 ) {
+	v *= vscale;
+	switch(c) {
+	case 'k': case 'K': iv = (int)(v * (1<<10)); break;
+	case 'm': case 'M': iv = (int)(v * (1<<20)); break;
+	case 'g': case 'G': iv = (int)(v * (1<<30)); break;
+	case '\0': iv = (int)(v * dscale); break;
+	default:
+	    ok = 0;
+	    break;
+	}
+    } else {
+	ok = 0;
+    }
+    if(ok) {
+	if(vmin < vmax && !(vmin <= iv && iv <= vmax)) {
+	    fprintf(stderr, "%s: %s: value '%s' = %d out of range %d..%d\n",
+		prog, why, str, iv, vmin, vmax);
+	    exit(1);
+	} else {
+	    return iv;
+	}
+    }
+    fprintf(stderr, "%s: %s: expected number (possibly with k/m/g suffix), not '%s'\n",
+	prog, why, str);
+    exit(1);
+}
+
+int
+main (int argc, char **argv)
+{
+  int sendRate;
+  int port = -1;
+  int verbose = 1;
+  float tv = 0;
+  int mtu;
+  char suf = '\0';
+  int c;
+  int bufsize = 64*1024*1024;
+
+  prog = argv[0];
+
+  while((c = getopt(argc, argv, "qvp:b:")) != EOF) {
+    switch(c) {
+    case 'v': verbose++; break;
+    case 'q': verbose = 0; break;
+    case 'p': port = getnumber( optarg, "UDP/TCP port number (default 38000)", 1, 65535 ); break;
+    case 'b': bufsize = getnumber( optarg, "Data block size (default 64m)", 8, 1<<30 ); break;
+    default:
+	argc = 0;
+	break;
+    }
+  }
+
+  if (argc < optind+3)
+    {
+      fprintf(stderr, "Usage: somesource | sendstream [options] <receiver> <sending rate (Kbps)> <packetsize>\n\
+Numbers may have 'k'/'m'/'g' suffix.  Example:\n\
+    tar cf - somedirectory | sendstream  128.101.25.35  600m  1460\n\
+Send rate in kbits/sec if no suffix given.\n\
+\"packetsize\" is actually max UDP payload size;\n\
+should be >= 40 bytes smaller than interface MTU, e.g. 1460 or 8800.\n\
+Options:\n\
+    -v		Verbose messages\n\
+    -q		No messages (errors only)\n\
+    -b <bufsize> Transfer in blocks of <bufsize>, default 64m bytes\n\
+    -p <port>	Use UDP/TCP <port> rather than 38000.\n\
+Firewall: sendstream listens on both UDP and TCP port 38000 (or <port>);\n\
+	recvstream listens on UDP port 38001 (or <port>+1)\n\n\
+Start \"sendstream\" first, then \"recvstream\".  Example:\n\
+   on sourcehost:   tar cf - ... | sendstream destIPaddr 250m 1460\n\
+then on desthost:   recvstream sourceIPaddr 1460 | tar xf -\n");
+      exit (1);
+    }
+
+  sendRate = getnumber( argv[optind+1], "sending bit rate (kbits/s unless suffix)", 0, 1<<30, 1000, 0.001 );
+
+  mtu = getnumber( argv[optind+2], "UDP payload data size (e.g. 1460, 8800)", 8, 100000 );
+  
+  if(port <= 0)
+    port = 38000;
+
+  QUANTAnet_rbudpSender_c *mysender = new QUANTAnet_rbudpSender_c (port);
+  mysender->init ( argv[optind] );
+  mysender->setverbose(verbose);
+
+  mysender->sendstream (0, sendRate, mtu, bufsize);
+
+  mysender->close ();
+
+  return 1;
+}
diff -Nur RBUDP.orig/tags RBUDP/tags
--- RBUDP.orig/tags	1969-12-31 18:00:00.000000000 -0600
+++ RBUDP/tags	2006-06-30 16:19:09.000000000 -0500
@@ -0,0 +1,45 @@
+!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
+!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
+!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
+!_TAG_PROGRAM_NAME	Exuberant Ctags	//
+!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
+!_TAG_PROGRAM_VERSION	5.5.4	//
+QMAX	QUANTAnet_rbudpReceiver_c.cxx	101;"	d	file:
+QMAX	QUANTAnet_rbudpReceiver_c.cxx	177;"	d	file:
+TRACE_DEBUG	QUANTAnet_rbudpReceiver_c.cxx	/^inline void TRACE_DEBUG( char *format, ...)$/;"	f
+TRACE_DEBUG	QUANTAnet_rbudpSender_c.cxx	/^inline void TRACE_DEBUG( char *format, ...)$/;"	f
+close	QUANTAnet_rbudpReceiver_c.cxx	/^void QUANTAnet_rbudpReceiver_c::close()$/;"	f	class:QUANTAnet_rbudpReceiver_c
+close	QUANTAnet_rbudpSender_c.cxx	/^void QUANTAnet_rbudpSender_c::close()$/;"	f	class:QUANTAnet_rbudpSender_c
+connectTCP	QUANTAnet_rbudpBase_c.cxx	/^int QUANTAnet_rbudpBase_c::connectTCP(char * host)$/;"	f	class:QUANTAnet_rbudpBase_c
+connectUDP	QUANTAnet_rbudpBase_c.cxx	/^void QUANTAnet_rbudpBase_c::connectUDP(char *host)$/;"	f	class:QUANTAnet_rbudpBase_c
+getfile	QUANTAnet_rbudpReceiver_c.cxx	/^int QUANTAnet_rbudpReceiver_c::getfile(char * origFName, char * destFName, int packetSize)$/;"	f	class:QUANTAnet_rbudpReceiver_c
+getfilelist	QUANTAnet_rbudpReceiver_c.cxx	/^int QUANTAnet_rbudpReceiver_c::getfilelist(char * fileList, int packetSize)$/;"	f	class:QUANTAnet_rbudpReceiver_c
+init	QUANTAnet_rbudpReceiver_c.cxx	/^void QUANTAnet_rbudpReceiver_c::init(char *remoteHost)$/;"	f	class:QUANTAnet_rbudpReceiver_c
+init	QUANTAnet_rbudpSender_c.cxx	/^void QUANTAnet_rbudpSender_c::init(char *remoteHost)$/;"	f	class:QUANTAnet_rbudpSender_c
+initErrorBitmap	QUANTAnet_rbudpBase_c.cxx	/^void QUANTAnet_rbudpBase_c::initErrorBitmap()$/;"	f	class:QUANTAnet_rbudpBase_c
+initReceiveRudp	QUANTAnet_rbudpReceiver_c.cxx	/^int QUANTAnet_rbudpReceiver_c::initReceiveRudp(void* buffer, int bufSize, int pSize)$/;"	f	class:QUANTAnet_rbudpReceiver_c
+initSendRudp	QUANTAnet_rbudpSender_c.cxx	/^int QUANTAnet_rbudpSender_c::initSendRudp(void* buffer, int bufSize, int sRate, int pSize)$/;"	f	class:QUANTAnet_rbudpSender_c
+initTCPServer	QUANTAnet_rbudpBase_c.cxx	/^void QUANTAnet_rbudpBase_c::initTCPServer()$/;"	f	class:QUANTAnet_rbudpBase_c
+listenAndInit	QUANTAnet_rbudpSender_c.cxx	/^void QUANTAnet_rbudpSender_c::listenAndInit()$/;"	f	class:QUANTAnet_rbudpSender_c
+listenTCPServer	QUANTAnet_rbudpBase_c.cxx	/^void QUANTAnet_rbudpBase_c::listenTCPServer()$/;"	f	class:QUANTAnet_rbudpBase_c
+main	recvfile.cxx	/^main (int argc, char **argv)$/;"	f
+main	recvfilelist.cxx	/^main (int argc, char **argv)$/;"	f
+main	sendfile.cxx	/^main (int argc, char **argv)$/;"	f
+main	sendfilelist.cxx	/^main (int argc, char **argv)$/;"	f
+main	urecv.cxx	/^main (int argc, char **argv)$/;"	f
+main	usend.cxx	/^main (int argc, char **argv)$/;"	f
+openSockets	QUANTAnet_rbudpSender_c.cxx	/^void QUANTAnet_rbudpSender_c::openSockets(char *remoteHost)$/;"	f	class:QUANTAnet_rbudpSender_c
+passiveUDP	QUANTAnet_rbudpBase_c.cxx	/^void QUANTAnet_rbudpBase_c::passiveUDP(char *host)$/;"	f	class:QUANTAnet_rbudpBase_c
+readn	QUANTAnet_rbudpBase_c.cxx	/^int QUANTAnet_rbudpBase_c::readn(register int fd, register char *ptr, register int nbytes)$/;"	f	class:QUANTAnet_rbudpBase_c
+receive	QUANTAnet_rbudpReceiver_c.cxx	/^void QUANTAnet_rbudpReceiver_c::receive(void * buffer, int bufSize, int packetSize)$/;"	f	class:QUANTAnet_rbudpReceiver_c
+reportTime	QUANTAnet_rbudpBase_c.cxx	/^int QUANTAnet_rbudpBase_c::reportTime(struct timeval & start)$/;"	f	class:QUANTAnet_rbudpBase_c
+send	QUANTAnet_rbudpSender_c.cxx	/^void QUANTAnet_rbudpSender_c::send(void * buffer, int bufSize, int sendRate, int packetSize)$/;"	f	class:QUANTAnet_rbudpSender_c
+sendfile	QUANTAnet_rbudpSender_c.cxx	/^int QUANTAnet_rbudpSender_c::sendfile(int sendRate, int packetSize)$/;"	f	class:QUANTAnet_rbudpSender_c
+sendfilelist	QUANTAnet_rbudpSender_c.cxx	/^int QUANTAnet_rbudpSender_c::sendfilelist(int sendRate, int packetSize)$/;"	f	class:QUANTAnet_rbudpSender_c
+udpReceive	QUANTAnet_rbudpReceiver_c.cxx	/^void QUANTAnet_rbudpReceiver_c::udpReceive()$/;"	f	class:QUANTAnet_rbudpReceiver_c
+udpReceiveReadv	QUANTAnet_rbudpReceiver_c.cxx	/^void QUANTAnet_rbudpReceiver_c::udpReceiveReadv()$/;"	f	class:QUANTAnet_rbudpReceiver_c
+udpSend	QUANTAnet_rbudpSender_c.cxx	/^void QUANTAnet_rbudpSender_c::udpSend()$/;"	f	class:QUANTAnet_rbudpSender_c
+udpSendWritev	QUANTAnet_rbudpSender_c.cxx	/^void QUANTAnet_rbudpSender_c::udpSendWritev()$/;"	f	class:QUANTAnet_rbudpSender_c
+updateErrorBitmap	QUANTAnet_rbudpBase_c.cxx	/^void QUANTAnet_rbudpBase_c::updateErrorBitmap(long long seq)$/;"	f	class:QUANTAnet_rbudpBase_c
+updateHashTable	QUANTAnet_rbudpBase_c.cxx	/^int QUANTAnet_rbudpBase_c::updateHashTable()$/;"	f	class:QUANTAnet_rbudpBase_c
+writen	QUANTAnet_rbudpBase_c.cxx	/^int QUANTAnet_rbudpBase_c::writen(register int fd, register char *ptr, register int nbytes)$/;"	f	class:QUANTAnet_rbudpBase_c
Files RBUDP.orig/urecv and RBUDP/urecv differ
diff -Nur RBUDP.orig/urecv.cxx RBUDP/urecv.cxx
--- RBUDP.orig/urecv.cxx	2006-05-26 12:36:37.000000000 -0500
+++ RBUDP/urecv.cxx	2006-12-20 16:07:20.000000000 -0600
@@ -22,42 +22,99 @@
 
 #include "QUANTAnet_rbudpReceiver_c.hxx"
 
+char *prog;
+
+int getnumber( char *str, char *why, int vmin, int vmax )
+{
+    int iv;
+    float v;
+    int ok = 1;
+    int c = '\0';
+    if( sscanf(str, "%f%c", &v, &c) > 0 ) {
+	switch(c) {
+	case 'k': case 'K': iv = (int)(v * (1<<10)); break;
+	case 'm': case 'M': iv = (int)(v * (1<<20)); break;
+	case 'g': case 'G': iv = (int)(v * (1<<30)); break;
+	case '\0': iv = (int)v; break;
+	default:
+	    ok = 0;
+	    break;
+	}
+    } else {
+	ok = 0;
+    }
+    if(ok) {
+	if(vmin < vmax && !(vmin <= iv && iv <= vmax)) {
+	    fprintf(stderr, "%s: %s: value '%s' = %d out of range %d..%d\n",
+		prog, why, str, iv, vmin, vmax);
+	    exit(1);
+	} else {
+	    return iv;
+	}
+    }
+    fprintf(stderr, "%s: %s: expected number (possibly with k/m/g suffix), not '%s'\n",
+	prog, why, str);
+    exit(1);
+}
+
 int
 main (int argc, char **argv)
 {
   char *buf;
-  int size, i;
-  long long totlen;
+  int i;
+  double totlen;
   struct timeval start, end;
   double throughput;
+  int verbose = 1;
+  prog = argv[0];
+
+  if(argc > 5 && 0==strcmp(argv[1], "-q"))
+    verbose = 0, argc--, argv++;
 
-  if (argc < 6)
+  if(argc > 5 && 0==strcmp(argv[1], "-v"))
+    verbose++, argc--, argv++;
+
+  if (argc < 5)
     {
       printf
-	("Usage: urecv <sender> <size of memory (Bytes)> <port> <ITER>\n <packetsize>");
+	("Usage: urecv [-q|-v] <sender> <bytes-to-transfer[k|m|g]> <packetsize> <ITER> [<port>(38000)]\n\
+Test memory-to-memory network performance of RBUDP transfers.\n\
+Soak up RBUDP test data sent by \"usend\".\n\
+Start \"usend\" first, then \"urecv\".  \"-q\"=> quiet, \"-v\"=>verbose.  E.g.:\n\
+  (on hostA)   usend  hostB  256m  800m  1460  4\n\
+  (on hostB)   urecv  hostA  256m  1460  4\n\
+transfers a 256-megabyte block at 800 megabits/sec, four times,\n\
+using 1460-byte UDP packets (to fit in 1500-byte Ethernet MTU),\n\
+averaging network performance across the four attempts.\n");
       exit (1);
     }
-  int iter = atoi (argv[4]);
-  int port = atoi (argv[3]);
-  size = atoi (argv[2]);
-  buf = (char *) malloc (size);
+  
+  
+  char *sender = argv[1];
+  int bigsize = getnumber( argv[2], "transfer size (bytes)", 8, (((unsigned int)1)<<31) - 1 );
+  int mtu = getnumber( argv[3], "UDP packet payload size (bytes)", 8, 32768 );
+  int iter = getnumber( argv[4], "Number of iterations", 1, 1<<30 );
+  int port = (argc<=5) ? 38000 : getnumber( argv[5], "TCP/UDP port number", 1, 65535 );
+  
+  buf = (char *) malloc (bigsize);
   if (buf == NULL)
     {
-      printf ("memory allocation fail.\n");
+      printf ("urecv: memory allocation fail.\n");
       exit (1);
     }
 
   QUANTAnet_rbudpReceiver_c *myreceiver =
     new QUANTAnet_rbudpReceiver_c (port);
-  myreceiver->init (argv[1]);
+  myreceiver->init (sender);
+  myreceiver->setverbose(verbose);
 
   printf ("init finishes\n");
   gettimeofday (&start, NULL);
   for (int j = 0; j < iter; j++)
-    myreceiver->receive (buf, size, atoi (argv[5]));
+    myreceiver->receive (buf, bigsize, mtu);
   gettimeofday (&end, NULL);
   myreceiver->close ();
-  totlen = size * 8.0 * iter;
+  totlen = bigsize * 8.0 * iter;
 
   /*
      // verify if the protocol transferred the exact data 
@@ -70,7 +127,8 @@
    */
 
 
+
   throughput = ((double) (totlen) / (double) USEC (&start, &end));
-  printf ("throughtput: %f Mbps\n", throughput);
-  return 1;
+  printf ("throughput: %f Mbps\n", throughput);
+  return 0;
 }
Files RBUDP.orig/usend and RBUDP/usend differ
diff -Nur RBUDP.orig/usend.cxx RBUDP/usend.cxx
--- RBUDP.orig/usend.cxx	2006-05-26 12:36:31.000000000 -0500
+++ RBUDP/usend.cxx	2006-12-21 15:50:18.000000000 -0600
@@ -22,42 +22,97 @@
 
 #include "QUANTAnet_rbudpSender_c.hxx"
 
+char *prog;
+
+int getnumber( char *str, char *why, int vmin, int vmax, float dscale = 1, float vscale = 1.0f )
+{
+    int iv;
+    float v;
+    int ok = 1;
+    int c = '\0';
+    if( sscanf(str, "%f%c", &v, &c) > 0 ) {
+	v *= vscale;
+	switch(c) {
+	case 'k': case 'K': iv = (int)(v * (1<<10)); break;
+	case 'm': case 'M': iv = (int)(v * (1<<20)); break;
+	case 'g': case 'G': iv = (int)(v * (1<<30)); break;
+	case '\0': iv = (int)(v * dscale); break;
+	default:
+	    ok = 0;
+	    break;
+	}
+    } else {
+	ok = 0;
+    }
+    if(ok) {
+	if(vmin < vmax && !(vmin <= iv && iv <= vmax)) {
+	    fprintf(stderr, "%s: %s: value '%s' = %d out of range %d..%d\n",
+		prog, why, str, iv, vmin, vmax);
+	    exit(1);
+	} else {
+	    return iv;
+	}
+    }
+    fprintf(stderr, "%s: %s: expected number (possibly with k/m/g suffix), not '%s'\n",
+	prog, why, str);
+    exit(1);
+}
+
+
+
 int
 main (int argc, char **argv)
 {
   char *buf;
-  int size, i;
-  int sendRate;
+  int verbose = 1;
+  prog = argv[0];
+
+  if(argc > 5 && 0==strcmp(argv[1], "-q"))
+    verbose = 0, argc--, argv++;
 
-  if (argc < 7)
+  if(argc > 5 && 0==strcmp(argv[1], "-v"))
+    verbose++, argc--, argv++;
+
+  if (argc < 6)
     {
       printf
-	("Usage: usend <receiver> <size of memory (Bytes)> <sending rate (Kbps)> <numITERS> < packetsize> <port> \n");
+	("Usage: usend [-q|-v] <receiver> <bytes-to-transfer[k|m|g]> <send-rate(Kbit/s unless k|m|g suffix)> <packetsize> <numITERs> [<port>]\n\
+Tests memory-to-memory speed of RBUDP block network transfers.\n\
+Start \"usend\" first, then \"urecv\".  \"-q\"=> quiet, \"-v\"=>verbose.  E.g.:\n\
+  (on hostA)   usend  hostB  256m  800m  1460  4\n\
+  (on hostB)   urecv  hostA  256m  1460  4\n\
+transfers a 256-megabyte block at 800 megabits/sec, four times,\n\
+using 1460-byte UDP packets (to fit in 1500-byte Ethernet MTU),\n\
+averaging network performance across the four attempts.\n");
       exit (1);
     }
-  int iter = atoi (argv[4]);
-  size = atoi (argv[2]);
+
+  int size = getnumber( argv[2], "transfer size (bytes)", 8, ((unsigned int)1)<<31 - 1 );
+  int sendRate = getnumber( argv[3], "sending bit rate (kbits/s unless k/m/g suffix)", 0, 1<<30, 1000, 0.001 );
+  int mtu  = getnumber( argv[4], "UDP payload data size (e.g. 1460 or 8800)", 8, 100000 );
+  int iter = getnumber( argv[5], "repetition count (sends count * transfersize bytes total)", 0, 1<<30 );
+  int port = argc<=6 ? 38000 : getnumber( argv[6], "UDP/TCP port (default 38000)", 1, 65535 );
   buf = (char *) malloc (size);
   if (buf == NULL)
     {
-      printf ("memory allocation fail.\n");
+      fprintf(stderr, "usend: can't allocate %d bytes for buffer.\n", size);
       exit (1);
     }
   // Initialize the buffer content in order to verify the protocol
-  for (i = 0; i < size / 4; i++)
-    *(int *) (buf + i * 4) = i;
-  sendRate = atoi (argv[3]);
+  for (int i = 0; i < size / sizeof(int); i++)
+    ((int *)buf)[i] = i;
   
   printf(" Creating sender Obj\n" );
 
-  QUANTAnet_rbudpSender_c *mysender = new QUANTAnet_rbudpSender_c (atoi (argv[6]));
+  QUANTAnet_rbudpSender_c *mysender = new QUANTAnet_rbudpSender_c (port);
   printf(" Sender To bbe initialized \n" ); 
   mysender->init (argv[1]);
+  mysender->setverbose(verbose);
   
   printf(" Sender has initialized \n" );
   
   for (int j = 0; j < iter; j++)
-    mysender->send (buf, size, sendRate, atoi (argv[5]));
+    mysender->send (buf, size, sendRate, mtu);
 
   mysender->close ();
   return 1;
